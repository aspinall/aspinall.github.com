<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: haskell | Craig Aspinall]]></title>
  <link href="http://www.craigaspinall.com/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://www.craigaspinall.com/"/>
  <updated>2012-06-14T22:44:45+10:00</updated>
  <id>http://www.craigaspinall.com/</id>
  <author>
    <name><![CDATA[Craig Aspinall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Is Haskell actually a simple language?]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/27/is-haskell-actually-simple/"/>
    <updated>2010-11-27T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/27/is-haskell-actually-simple</id>
    <content type="html"><![CDATA[<p>Whilst I was writing the previous post about learning Haskell, I was reminded of "a post by Martin Odersky":http://lamp.epfl.ch/~odersky/blogs/isscalacomplex.html about the complexity or otherwise of Scala. In that post he tries several metaphors to determine what <em>simple</em> really means, finally settling on Duplo versus Technics Lego. You can build anything with either (just as you can with turing complete languages) but a solution built with Duplo is unlikely to be as elegant as a solution built with Technics.</p>

<p>I like his comparison because it shows how much <em>simplicity</em> is a concept that means different things to different people. I'm starting to think that Haskell is a really simple language, even though I'm finding it difficult to learn!</p>

<p>One of the relative measures of complexity used in the article is the number of keywords in a language. Carlos Quintanilla's "comparison of CLR and JVM languages":http://carlosqt.blogspot.com/2010/07/how-many-keywords-do-you-type-in-your.html ranges from 139 to 31 keywords. Haskell has just 20!</p>

<p>And the more I use the language, the more it strikes me as being ruthlessly consistent. Take functions for example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Nominally you can read this as a function called @add@ that takes two @Int@ parameters and returns an @Int@. Except it isn't. It's a function that takes an @Int@ and returns another function that takes an @Int@ and returns an @Int@! Which means you can do this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">plusOne</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">plusOne</span> <span class="ow">=</span> <span class="n">add</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I've defined a @plusOne@ function by fixing the first parameter of @add@ to @1@, which returns a function that will always add 1 to whatever value is passed to it. By applying the same principle again we have a function that takes no arguments and returns an @Int@.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">two</span> <span class="ow">=</span> <span class="n">plusOne</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This concept is one of the reasons why I'm struggling with Functors. It seems mind numbingly simple to me and yet so mind bogglingly powerful at the same time!</p>

<p>And that is the paradox I keep banging my head against!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell's type system made me cry]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/26/haskells-type-system-made-me-cry/"/>
    <updated>2010-11-26T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/26/haskells-type-system-made-me-cry</id>
    <content type="html"><![CDATA[<p>My functional programming with Haskell journey continues and every time I think I understand something, I discover there's another layer of complexity underneath the one I just peeled off! There are so many metaphors that spring to mind that I'm just going to avoid them all!</p>

<p>What I've found so far is that I typically go through three or four stages of learning functional concepts. In the first stage I don't understand it at all. In the second stage I start learning matched pairs of input and results, so I can start to use the concept but I don't understand how the input is transformed to the output. In the third stage I start to get that understanding of how it works as well as what it does. And in the fourth stage I realise how much more there is that I don't understand yet!</p>

<p>This week I really started to understand type classes and monads, only to discover that monads are just the tip of the iceberg. My brain then started to melt as I went back to stage one and two with functors and applicative functors!</p>

<p>It's also beginning to dawn on me just how amazing the Haskell type system is. One of my friends once said that Haskell's type system made him cry. Not tears of pain but tears of joy at how elegant it is!</p>
]]></content>
  </entry>
  
</feed>
