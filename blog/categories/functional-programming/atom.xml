<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: functional programming | Craig Aspinall]]></title>
  <link href="http://www.craigaspinall.com/blog/categories/functional-programming/atom.xml" rel="self"/>
  <link href="http://www.craigaspinall.com/"/>
  <updated>2012-06-15T21:57:54+10:00</updated>
  <id>http://www.craigaspinall.com/</id>
  <author>
    <name><![CDATA[Craig Aspinall]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is functional programming?]]></title>
    <link href="http://www.craigaspinall.com/blog/2011/06/23/what-is-functional-programming/"/>
    <updated>2011-06-23T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2011/06/23/what-is-functional-programming</id>
    <content type="html"><![CDATA[<p>I gave a talk at our "Coding By Numbers meetup":http://www.meetup.com/CodingByNumbers/events/21665201 tonight that attempts to peel away some of the mystery surrounding that question. It was a small audience but they appeared to appreciate it and I hope I was able to show them that many of the benefits of functional programming are easily accessible.</p>

<p>I originally put this presentation together for a functional programming group that I started at work, for those that are interested in learning more about functional programming and ultimately applying it to their day jobs.</p>

<!--more-->


<p>The focus of the presentation is really about getting to the crux of what functional programming is, and away from all the FUD(Fear Uncertainty and Doubt) that surrounds it. It also presents a simple example in Java, refactoring a "naive" solution into one that is more readable, testable and maintainable, by applying functional programming principles. The presentation finishes off with an example solution to the same problem in Haskell.</p>

<p>The "handout":talks/what-is-fp/handout.pdf contains the slides with all of my reader notes, which is essentially a transcript of the presentation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is Haskell actually a simple language?]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/27/is-haskell-actually-simple/"/>
    <updated>2010-11-27T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/27/is-haskell-actually-simple</id>
    <content type="html"><![CDATA[<p>Whilst I was writing the previous post about learning Haskell, I was reminded of "a post by Martin Odersky":http://lamp.epfl.ch/~odersky/blogs/isscalacomplex.html about the complexity or otherwise of Scala. In that post he tries several metaphors to determine what <em>simple</em> really means, finally settling on Duplo versus Technics Lego. You can build anything with either (just as you can with turing complete languages) but a solution built with Duplo is unlikely to be as elegant as a solution built with Technics.</p>

<!--more-->


<p>I like his comparison because it shows how much <em>simplicity</em> is a concept that means different things to different people. I'm starting to think that Haskell is a really simple language, even though I'm finding it difficult to learn!</p>

<p>One of the relative measures of complexity used in the article is the number of keywords in a language. Carlos Quintanilla's "comparison of CLR and JVM languages":http://carlosqt.blogspot.com/2010/07/how-many-keywords-do-you-type-in-your.html ranges from 139 to 31 keywords. Haskell has just 20!</p>

<p>And the more I use the language, the more it strikes me as being ruthlessly consistent. Take functions for example:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Nominally you can read this as a function called @add@ that takes two @Int@ parameters and returns an @Int@. Except it isn't. It's a function that takes an @Int@ and returns another function that takes an @Int@ and returns an @Int@! Which means you can do this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">plusOne</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</span><span class='line'><span class="nf">plusOne</span> <span class="ow">=</span> <span class="n">add</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I've defined a @plusOne@ function by fixing the first parameter of @add@ to @1@, which returns a function that will always add 1 to whatever value is passed to it. By applying the same principle again we have a function that takes no arguments and returns an @Int@.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">two</span> <span class="ow">=</span> <span class="n">plusOne</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This concept is one of the reasons why I'm struggling with Functors. It seems mind numbingly simple to me and yet so mind bogglingly powerful at the same time!</p>

<p>And that is the paradox I keep banging my head against!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell's type system made me cry]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/26/haskells-type-system-made-me-cry/"/>
    <updated>2010-11-26T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/26/haskells-type-system-made-me-cry</id>
    <content type="html"><![CDATA[<p>My functional programming with Haskell journey continues and every time I think I understand something, I discover there's another layer of complexity underneath the one I just peeled off! There are so many metaphors that spring to mind that I'm just going to avoid them all!</p>

<p>What I've found so far is that I typically go through three or four stages of learning functional concepts. In the first stage I don't understand it at all. In the second stage I start learning matched pairs of input and results, so I can start to use the concept but I don't understand how the input is transformed to the output. In the third stage I start to get that understanding of how it works as well as what it does. And in the fourth stage I realise how much more there is that I don't understand yet!</p>

<!--more-->


<p>This week I really started to understand type classes and monads, only to discover that monads are just the tip of the iceberg. My brain then started to melt as I went back to stage one and two with functors and applicative functors!</p>

<p>It's also beginning to dawn on me just how amazing the Haskell type system is. One of my friends once said that Haskell's type system made him cry. Not tears of pain but tears of joy at how elegant it is!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Take the red pill...]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/09/take-the-red-pill/"/>
    <updated>2010-11-09T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/09/take-the-red-pill</id>
    <content type="html"><![CDATA[<p>Right now I feel a bit like Neo being confronted by Morpheus and offered the choice of the blue pill or the red pill. Take the blue pill and I can go back to my comfortable world of Java and object orientation. Take the red pill - I learn Haskell and see how deep functional programming goes!</p>

<!--more-->


<p>In a previous post I mentioned that I am in the process of learning functional programming in Haskell. The exercise this week was to write a monadic parser and what struck me about it was how much I was wrestling to keep a single function in my head. With Java I can hold several classes and the interactions between them in my head, and even do a half decent job with multi-threaded code (I'm sure "Tony":http://blog.tmorris.net/ would disagree and he's probably right, but for now I am no more disillusioned than most Java programmers).</p>

<p>I think the part of the reason I struggled is because Haskell code is a lot more dense than Java code i.e. less code does more. The type system in particular, is so rich that trying to keep track of what types were in play at each point in the function was a challenge in itself. Whilst I was working on the exercises, I got to a point where I knew the understanding I needed was just beyond my grasp, and the penny dropped just as I answered the last question!</p>

<p>It was at that point that I began to understand what one of the functions I had written early on actually did. That enabled me to clean up my code considerably because I had been rewriting the same function over and over in the subsequent questions. That in turn made the code a lot easier to reason about.</p>

<p>It really shows the importance of understanding a function before you use it. At the end of today's lesson we had an interesting discussion about unwittingly misunderstanding code, because we think we understand it when actually we don't. Languages like Haskell can reduce the ambiguity which reduces the chance of misunderstanding. Unfortunately, it can also lead to non-understanding for beginners like me, which isn't much help either!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Follow the types (not the white rabbit)!]]></title>
    <link href="http://www.craigaspinall.com/blog/2010/11/04/follow-the-types/"/>
    <updated>2010-11-04T00:00:00+10:00</updated>
    <id>http://www.craigaspinall.com/blog/2010/11/04/follow-the-types</id>
    <content type="html"><![CDATA[<p>For a while I have been trying to learn "Haskell":http://www.haskell.org/ as a way of getting my head completely around functional programming. I started with ""Seven Languages in Seven Weeks":http://www.pragprog.com/titles/btlang/seven-languages-in-seven-weeks", moved on to ""Real World Haskell":http://www.realworldhaskell.org/", and now, "Tony Morris":http://blog.tmorris.net/ is very kindly donating some of his time to help me and a few other guys to get to grips with the concepts that underpin the language.</p>

<!--more-->


<p>Every week, he sets exercises for us to complete, which involves writing solutions to a bunch of functions that pass the acceptance tests that he supplied. This week we are writing a parser, but the real challenge for me is that none of the tests will pass until all of the functions have been completed. Writing around 20 functions before being able to get any feedback is almost a bigger challenge than writing the functions themselves!</p>

<p>Tony's advice was to "follow the types" and I'm sure he is right. If you follow the type signatures and you have a vague notion of what the function is supposed to do, there are only a limited number of options open to you. The HaskellWiki also says that ""Once your code compiles it usually works":http://www.haskell.org/haskellwiki/Why_Haskell_just_works". I'm halfway through the functions and really hoping that is true! Perhaps I'll report back in a future post.</p>

<p>In any case, I can already say that what I have learned so far has influenced the code I write, and I can only see good things coming from having a better understanding of type theory and functional programming.</p>
]]></content>
  </entry>
  
</feed>
