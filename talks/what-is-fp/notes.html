<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
</head>
<body>
<h1 id="typical-fizzbuzz-answer-in-java">Typical “FizzBuzz” Answer in Java</h1>
<p>This is pretty much what I would expect most Java developers to write. It does what it’s supposed to with the minimum of fuss.</p>
<p>It’s also very dense and difficult to work out from the code what it is supposed to be doing.</p>
<p>Our IO is intertwined with our “business logic” and it would be very difficult to test our business logic as a result. We would have to execute the main () method and capture the output from stdout to be able to prove anything.</p>
<h1 id="a-better-fizzbuzz-answer">A Better “FizzBuzz” Answer</h1>
<p>Here I’ve refactored the code to make it more testable.</p>
<p>I’ve separated the IO from the business logic, by creating a function that accepts an int and returns a List of Strings. The integer argument tells us which number we want to “fizzbuzz” up to, and the list of strings is the corresponding “fizzbuzz” sequence.</p>
<p>And as you can see, now the main method just iterates over what is returned from our fizzBuzz () function and outputs it. This is so simple it shouldn’t require any specific testing.</p>
<p>Since the fizzBuzz () function doesn’t operate on anything other than it’s arguments we can test it thoroughly in solation of the IO code. Once we have some tests in place, then we can look at further refactorings.</p>
<h1 id="a-more-functional-fizzbuzz-answer-in-java">A More Functional “FizzBuzz” Answer in Java</h1>
<p>This appears to be much longer but it is also much easier to figure out what it is supposed to be doing.</p>
<ol>
<li>The main () method is now iterating over the collection of Strings returned from the fizzBuzz () methods and printing them out.</li>
<li>The fizzBuzz () method is counting from 1 to the supplied upper bound and adding the result of fizzBuzzOrNumber () to a list of Strings, which it then returns.</li>
<li>The fizzBuzzOrNumber () method checks to see if the number it is passed is a multiple of 3 or 5, both or neither, and returns different results accordingly.</li>
<li>We probably don’t even need to look at the implementations of isMultipleOf3 () or isMultipleOf5 () to know what they do, it’s obvious from the name and the context.</li>
</ol>
<p>We now have something we can now thoroughly test. All of the “methods” are actually pure functions, with a single, clear purpose, that operate only on their arguments. I’ve also made all the variables immutable so the functions are referentially transparent.</p>
<h1 id="a-functional-fizzbuzz-answer-in-haskell">A Functional “FizzBuzz” Answer in Haskell</h1>
<p>This is an approximation of the functional “FizzBuzz” answer in Java and probably doesn’t represent idiomatic Haskell, but it makes it easier to point out where there are significant differences.</p>
<p>Haskell uses type inference so we don’t have to declare any types, although everything is strongly and statically typed.</p>
<p>It doesn’t require parentheses around function arguments or semi-colons at the end of functions.</p>
<p>We can place binary functions in the infix position by surrounding the function name with back quotes.</p>
<p>if-then-else is not used for control flow as it is in imperative languages like Java, it is used to select from two possible return expressions based on some boolean expression. In this case we have nested if constructs but they all ultimately resolve to return a single value or expression.</p>
<p>Whitespace is used to distinguish new declarations from line continuations. If we placed any of the if constructs at the left margin it wouldn’t compile.</p>
<p>The map function takes two arguments, a function to convert values of type A to values of type B, and a list of values of type A, and returns a list of values of type B. In this case we pass it a list of integers from 1 to the upper bound, and the fizzBuzzOrNumber function to convert the integer values into the corresponding strings.</p>
<p>Finally have the main function. Here the forM_ function accepts a list of values of type A and a function that operates on values of type A and it applies the function to every value in the list in order. We supply the result of (fizzBuzz 100) as the list and putStrLn which outputs strings to stdout followed by a newline character.</p>
<p>You may or may not have noticed a number a significant language traits in action here.</p>
<ol>
<li>fizzBuzz and forM_ are higher order functions, which in turn means that functions are first class values</li>
<li>Haskell lists are recursively defined algebraic data types</li>
<li>There are 2 instances of monads on show
<ol>
<li>Haskell lists are also instances of monads</li>
<li>All IO in Haskell is contained within the IO monad</li>
</ol></li>
</ol>
<p>So if you can grok the Haskell example, how hard can these concepts be?</p>
</body>
</html>
