---
layout: s5
title: What is functional programming?
author: Craig Aspinall
affiliation: Co-host of Coding By Numbers
---
<div class="slide">
h1. The stuff of myth and legend!

<div class="image-right">
!/talks/what-is-fp/images/occult.gif!
</div>

There is a lot of misinformation and misinterpretation around what functional programming is. 

It's not the black art that some would have you believe!

Let us start by defining some of the things that functional programming is not.

<div class="handout">
Let's start by dispelling some of the myths. Functional programming is still seen as a black art by some developers, something occult, which of course, it isn't.

It does inherit a lot of terminology from branches of advanced mathematics, such as category theory, but you don't need to know or understand that to get started with functional programming. At it's very essence, it's quite simple so let's start by defining some of the things that functional programming is not about.
</div>
</div>

<div class="slide">
h1. It is not about...

<div class="image-right">
!/talks/what-is-fp/images/red-cross.png!
</div>
* Type systems:
** strong versus weak
** static versus dynamic
* Lazy versus strict evaluation
* Higher order functions
* Monads, monoids, functors etc.

These questions apply to both functional and non-functional programming!
<div class="handout">
It is not about type systems. The questions of string versus weak, and dynamic versus static typing have nothing to do with functional programming. Neither does the question of lazy versus strict (or eager) evaluation.

There are lots of features that are commonly associated with functional programming like higher order functions, monads, monoids, functors etc. but functional programming is not about those either.

All of these things can apply to both functional and non functional programming.
</div>
</div>

<div class="slide">
h1. So what is functional programming about?

To answer that, we need to go back in time, to the 1930s.

<div class="image-center">
!/talks/what-is-fp/images/depression.jpg!
</div>
<div class="handout">
So what is functional programming really about? To answer that question we need to look back to where it all began, in 1930s America.

This was of course the time of the great depression. Unemployment was rife and many families were struggling to put food on the table. Even the wealthy had lost a fortune on the stock market and were forced to sell their belongings at knocked down prices.
</div>
</div>

<div class="slide">
h1. Princeton University

<div class="image-left">
!/talks/what-is-fp/images/princeton.jpg!
</div>

In the 1930s at Princeton university, there were a number of individuals trying to answer questions related to *computation*, such as:

bq. "If we had infinite computing power, what problems would we be able to solve?"

<div class="handout">
With industry and society on its knees, many of the best minds of the time worked in academia. The top universities were a haven from what was going on in the rest of the country. 

From a functional programming perspective, we're most interested in Princeton University in New Jersey. There were a number of individuals there who were interested in the subject of computation, and were trying to answer questions such as:

* If we had infinite computing power, what problems would we be able to solve?
* Would there be any problems we could not solve?
* Could they be solved in more than one way?

If you come from a computer science background, you may recognize the names of a few of them!
</div>
</div>

<div class="slide">
h1. Alonzo Church

<div class="image-right">
!/talks/what-is-fp/images/Alonzo_Church.jpg!
</div>
Alonzo Church developed a formal system called *lambda calculus*, essentially a programming language for a machine with infinite power. 

It was based on *functions* that took other *functions* as parameters and returned *functions*. 

Using this he was able to provide conclusive answers to the many of the computation questions.
<div class="handout">
One of those individuals was Alonzo Church. He developed a formal system called lambda calculus that was essentially a programming language for one of these imaginary machines with unlimited computing power.

Lambda calculus is based on functions that take other functions as parameters and return functions as results. You can probably guess where we're going with this!

Using lambda calculus, Church was able to provide answers to many of the computation related questions that the academics were asking.
</div>
</div>

<div class="slide">
h1. Alan Turing

<div class="image-right">
!/talks/what-is-fp/images/Alan_Turing.jpg!
</div>
Alan Turing independently developed a different formal system now known as the *Turing machine*. 

Using his system Turing arrived at similar conclusions to Alonzo Church.

It was later shown that Turing machines and lambda calculus were equivalent in power.
<div class="handout">
Another one of the individuals at Princeton was Alan Turing. If you haven't heard of Alonzo Church before I'm sure you will have heard of the Turing machine.

The Turing machine was another formal system that Turing developed independently of the work that Church was doing, and using it he was also able to provide answers to the computation related questions.

Unlike lambda calculus, a Turing machine is very much a state based system, reading instructions from a tape and performing actions such as moving the tape head back and forth and writing output. The concept of a function is missing from it.

It was later shown that Turing machines and lambda calculus were equivalent in power. Whatever could be achieved in one could also be achieved in the other. This is important to remember as we look at how we can perform functional programming in different programming languages.
</div>
</div>

<div class="slide">
h1. John von Neumann

<div class="image-right">
!/talks/what-is-fp/images/John_von_Neumann.jpg!
</div>
John von Neumann developed what we now call "von Neumanns architecture". 

In 1949 the EDVAC (Electronic Discrete Variable Automatic Computer) was unveiled and was the first example of von Neumanns architecture, effectively a real world implementation of a Turing machine.
<div class="handout">
Another person who was at Princeton at the time and you might have heard of, was John von Neumann. He developed what we now call "von Neumann's architecture", something that is still prevalent in todays CPUs.

In 1949 the EDVAC (Electronic Discrete Variable Automatic Computer) was unveiled and was the first example of von Neumanns architecture, effectively a real world implementation of a Turing machine. So this time Church missed out and Turing claimed the crown, but Church was still to have his day.
</div>
</div>

<div class="slide">
h1. John McCarthy

<div class="image-left">
!/talks/what-is-fp/images/John_McCarthy.jpg!
</div>
In 1958, John McCarthy unveiled the LISP (LISt Processing) language whilst working at MIT.

This was an implementation of lambda calculus that worked on von Neumann architectures.

<div class="handout">
Almost 10 years later, in 1958, John McCarthy (a Princeton graduate working at MIT at the time) unveiled LISP (LISt Processing language). LISP was an implementation of lambda calculus that worked on von Neumann architectures. This proved that the Turing machine and lambda calculus were equivalent and one could be implemented in terms of the other.

There are still ardent supporters of LISP who believe that it is the one true way of programming computers, and yet it still hasn't captured the mindshare of the majority of developers out there.
</div>

<div class="slide">
h1. So, what is functional programming?

Unsurprisingly, functional programming is a practical implementation of lambda calculus and at the core of it is the *function*!

<div class="image-center">
!/talks/what-is-fp/images/Half_Life_Logo.jpg!
</div>

bq. Practical in the sense that not all lambda calculus ideas can be implemented under physical limitations!

<div class="handout">
Hopefully you arrived at the answer by now, but functional programming is a practical implementation of Church's lambda calculus. We say practical because lambda calculus was intended for machines with infinite computing power, which we don't have (yet), so not all of the ideas translate to reality.

And the most important part of lambda calculus for practical functional programming is the function itself. Remember that functions were used for nearly everything in lambda calculus. So we should look at what a function is and where variables come in?
</div>
</div>

<div class="slide">
h1. So, what is functional programming?

A variable:
* is an alias for an expression
* is assigned to once
* is never modified

<div class="handout">
Well, in functional programming variables are really just aliases for expressions. We can assign to them once and then we can't modify them.

If we want to mutate a variable then we create a copy with the new value and leave the old one in place. Sometimes this is enforced by the language and the rest of the time we have to be disciplined about it.
</div>
</div>

<div class="slide">
h1. So, what is functional programming?

A function:
* always takes at least one argument
* always returns a result
* does not operate on anything other than its arguments (if it's pure)
** no side effects
** guaranteed to return the same result given the same arguments

<div class="handout">
What are functions?

Functions always take at least one argument and return some result. They do not operate on anything other than its arguments, at least if it's a pure function, which is what we are aiming for. Pure functions have no side effects, and by side effects we mean that the only visible change in the system as a result of calling the function is whatever it returns. Pure functions are therefore guaranteed to return the same result given the same argument values.

Note that there can be no such thing as a void function because that would imply that either:
# the function doesn't do anything, in which case it is pointless, or
# it is mutating one of the arguments which we supplied, which means we don't have immutable data and can't guarantee side effect free code, or
# it's operating on something other than the arguments which we supplied, which also means we can't guarantee sde effect free code!
</div>
</div>

<div class="slide">
h1. Why should we care?

<div class="image-center">
!/talks/what-is-fp/images/transparency.jpg!
</div>

bq. "referential transparency"

<div class="handout">
So at this point you might be thinking that this functional programming lark doesn't sound quite as scary as you thought it was. You're also probably thinking that you and the majority of developers in the last couple of decades have been managing very nicely with imperative object oriented programming thank you very much, so why would you be bothered to fix something that isn't broken?

Well, it all boils down to referential transparency, which is a fancy way of saying the last point on the previous slide. Given a pure function and a set of immutable argument values, we will always get the same result, regardless of when we call it, or how many times we call it, or what other functions we call before it. It guaranteed to return the same result every time.

It's predictable. And that has major implications.
</div>
</div>

<div class="slide">
h1. Referential transparency means...

<div class="image-right">
!/talks/what-is-fp/images/testing.jpg!
</div>
* easier testing
* easier debugging
* easier re-use
* implicit thread safety

<div class="handout">
Referentially transparency makes it much easier to unit test your code, because you have well defined inputs and outputs to your functions, and the only thing that can affect those output are the inputs.

Debugging your code becomes much simpler too, because the behaviour of your function does not depend on anything that happened before it was called, it only depends on the values of its arguments.

Since your functions don't depend on anything around them, and they tend to have a single, well defined purpose, they are easier to re-use too.

It also means that your code is implicitly thread safe, because there is no shared mutable state, so it is ready to take advantage of all those CPU cores!

Whilst there is no shared mutable state, it isn't true to say that there is no state. It's just that the state is held on the stack in the function arguments, rather than a shared location in the heap.
</div>
</div>
